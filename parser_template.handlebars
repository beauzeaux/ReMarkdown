/**
 * Created by beauzeaux on 12/21/13.
 */
{
     /**
      * Creates a new element and returns it
      * @param type the type of element
      * @param value the element's value
      */
     var element = function(type, value) {
         return {"type" : type, "value": value};
     };

    //== Span Level Helper Functions ==
    /**
     * Stack of span closing tags
     * @type {Array}
     */
    var spanClose = new Array();

    /**
     * Determines if the pointer is at the end of the inner-most
     * span-level element
     * @param input the input variable from peg.js
     * @param offset the offset variable from peg.js
     * @returns {boolean} if the next character is the closing for the inner-most span
     */
    var checkSpanClose = function(input, offset) {
        var check = spanClose[spanClose.length -1];
        if (check == null) return false;
        return input.substring(offset, offset+check.length) === check;
    };

    /**
     * Removes a span closing tag from the stack
     * @param expected
     * @returns {boolean}
     */
    var removeSpanClose = function(expected) {
        var ret = spanClose.pop();
        if (ret !== expected)
        {
            var msg = "Invalid Closing Found!\n" +
                      "Expected: " + expected + "\n" +
                      "Found: " + ret + "\n" +
                      spanClose.join("") + "\n";
            var e = new Error(msg);
            throw e;
        }
        return true;
    };

    //== Block Level Helper Functions ==

    var blockPrefixCallback = new Array();

    //Kludgy prefix helper
    var checkBlockPrefix = function(input, offset, line, column)
    {
        var adv = 0;
        if (blockPrefixCallback.length == 0) return true;
        for (var i = 0; i < blockPrefixCallback.length; i++) {
            off = blockPrefixCallback[i](input, offset, line, column);
            if (off == -1) return false;
            adv += off
            offset += off;
        }
        advance(pos, adv);
        return true;
    };

    {{{prelude}}}
}

start =
    head:DocumentHeader?
    NewLine*
    blocks:Block*
    EOF
{
    return {type: "document", value: blocks, title:head.title, authors:head.authors};
}

DocumentHeader =
    "title:"
    title: Text
    NewLine
    authors:("author:" author:Inline NewLine {return author})*
{
    return {title: title, authors:authors};
}

FAILURE =
    &{return false;}


// == BLOCK ELEMENTS == //

BlockPrefix =
    &{return checkBlockPrefix(input, offset, line, column);}

Block =
    b:(BlockElement/
    Paragraph /
    Singleton)
    (BlockPrefix? NewLine)*
{ return b;}

Paragraph =
    vals:(!BlockElement
          BlockPrefix
          v:Inline
          NewLine
          {return v;})+
    (!BlockPrefix / BlockPrefix? NewLine/  &EOF)
{
    // thanks to ninjageko from stackoverflow
    // question 5080028
    var ret = [].concat.apply([], vals);
    return {"type" : "Paragraph", value: ret};
}

Singleton =
    !BlockElement
    !Paragraph
    BlockPrefix value:Inline
{
    return {"type": "Singleton", value:value};
}

BlockElement ={{#each BlockElements}}
   {{name}} /{{/each}}
   FAILURE

{{#each BlockElements}}
{{{name}}} =
{{{rule}}}
{
    return element("{{name}}",vals);
}
{{/each}}

//== Span Elements ==//

Inline =
    values:(Span / Text)+

Span ={{#each SpanElements}}
  {{name}}/{{/each}}
  FAILURE

{{#each SpanElements}}
{{{name}}} =
{{{rule}}}
{
    return element("{{{name}}}", text);
}
{{/each}}

//== Additional Rules ==/

Text =
    text:(!Span
    !NewLine
    !{return checkSpanClose(input, offset);}
    char:. {return char})+
{
    return element("text", text.join(""));
}

NewLine =
    "\r"? //windows you caused me a great deal of pain with this one
    "\n"

NewLines =
    NewLine+

EOF =
    !.

// These are arbitrary for quick use
{{#each AdditionalElements}}
{{{this}}}
{{/each}}


//END OF TEMPLATE